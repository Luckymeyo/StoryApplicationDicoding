{"version":3,"sources":["webpack://app-starter-project-with-webpack/./src/scripts/sw-template.js"],"names":["importScripts","workbox","console","log","core","version","precaching","precacheAndRoute","self","__WB_MANIFEST","registerRoute","setCatchHandler","routing","NetworkFirst","StaleWhileRevalidate","CacheFirst","strategies","CacheableResponsePlugin","cacheableResponse","ExpirationPlugin","expiration","url","href","startsWith","cacheName","plugins","statuses","maxEntries","maxAgeSeconds","origin","includes","offlinePagePath","event","request","mode","caches","match","then","res","fetch","catch","Response","status","statusText","headers","error","addEventListener","title","options","body","icon","badge","data","json","Object","assign","err","warn","waitUntil","registration","showNotification","notification","close","clients","matchAll","type","includeUncontrolled","list","find","c","endsWith","focus","openWindow","skipWaiting","claim"],"mappings":"MAWA,GAVA,cAAc,2EAUV,QAAS,CACX,QAAQ,IAAI,gBAAgB,QAAQ,KAAK,mBAGzC,QAAQ,WAAW,iBAAiB,s1CAAK,eAEzC,MAAM,cAAE,EAAa,gBAAE,GAAoB,QAAQ,SAC7C,aAAE,EAAY,qBAAE,EAAoB,WAAE,GAAe,QAAQ,YAC7D,wBAAE,GAA4B,QAAQ,mBACtC,iBAAE,GAAqB,QAAQ,WAGrC,GACE,EAAG,SAAU,EAAI,KAAK,WAAW,oCACjC,IAAI,EAAa,CACf,UAAW,qBACX,QAAS,CACP,IAAI,EAAwB,CAAE,SAAU,CAAC,EAAG,OAC5C,IAAI,EAAiB,CAAE,WAAY,IAAK,cAAe,aAM7D,GACE,EAAG,SAAU,EAAI,OAAO,SAAS,yBAA2B,EAAI,OAAO,SAAS,sBAChF,IAAI,EAAqB,CACvB,UAAW,qBACX,QAAS,CACP,IAAI,EAAwB,CAAE,SAAU,CAAC,EAAG,OAC5C,IAAI,EAAiB,CAAE,WAAY,GAAI,cAAe,cAM5D,GACE,EAAG,SAAU,EAAI,KAAK,WAAW,0CACjC,IAAI,EAAW,CACb,UAAW,oBACX,QAAS,CACP,IAAI,EAAwB,CAAE,SAAU,CAAC,EAAG,OAC5C,IAAI,EAAiB,CAAE,WAAY,EAAG,cAAe,cAM3D,MAAM,EAAkB,eACxB,GAAgB,EAAG,WACU,aAAvB,EAAM,QAAQ,MAChB,QAAQ,IAAI,oBAAoB,KACzB,OAAO,MAAM,GACjB,MAAK,GAAO,GAAO,MAAM,KACzB,OAAM,IAAM,IAAI,SAAS,8BAA+B,CACvD,OAAQ,IACR,WAAY,UACZ,QAAS,CAAE,eAAgB,mBAG1B,SAAS,SAGpB,MACE,QAAQ,MAAM,gCAIhB,KAAK,iBAAiB,QAGtB,KAAK,iBAAiB,QAAQ,IAC5B,QAAQ,IAAI,sBACZ,IAAI,EAAQ,YACR,EAAU,CACZ,KAAM,kBACN,KAAM,sBACN,MAAO,sBACP,KAAM,CAAE,IAAK,SAGf,IACE,GAAI,EAAM,KAAM,CACd,MAAM,EAAO,EAAM,KAAK,OACxB,EAAQ,EAAK,OAAS,EAClB,EAAK,SAAmC,iBAAjB,EAAK,SAC9B,OAAO,OAAO,EAAS,EAAK,QAEhC,CACF,CAAE,MAAO,GACP,QAAQ,KAAK,mCAAoC,EACnD,CAEA,EAAM,UACJ,KAAK,aAAa,iBAAiB,EAAO,GAC3C,IAGH,KAAK,iBAAiB,qBAAqB,IACzC,EAAM,aAAa,QACnB,MAAM,EAAM,EAAM,aAAa,MAAM,KAAO,OAC5C,EAAM,UACJ,QAAQ,SAAS,CAAE,KAAM,SAAU,qBAAqB,IACrD,MAAK,GAAQ,EAAK,MAAK,GAAK,EAAE,IAAI,SAAS,MAAO,SAAW,QAAQ,WAAW,KACpF,IAGH,KAAK,iBAAiB,WAAW,KAAQ,KAAK,aAAa,IAC3D,KAAK,iBAAiB,YAAY,KAAQ,QAAQ,OAAO","file":"sw-template.js","sourceRoot":"","sourcesContent":["// src/scripts/sw-template.js\r\nimportScripts('https://storage.googleapis.com/workbox-cdn/releases/7.1.0/workbox-sw.js');\r\n\r\ntry {\r\n  //importScripts('./db.bundle.js');\r\n} catch (e) {\r\n  console.error('[SW] Failed DB import:', e);\r\n  self.getOutboxItems = async () => [];\r\n  self.clearOutbox   = async () => {};\r\n}\r\n\r\nif (workbox) {\r\n  console.log(`[SW] Workbox ${workbox.core.version} loaded.`);\r\n\r\n  // <-- precache all assets (injected by Workbox) -->\r\n  workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);\r\n\r\n  const { registerRoute, setCatchHandler } = workbox.routing;\r\n  const { NetworkFirst, StaleWhileRevalidate, CacheFirst } = workbox.strategies;\r\n  const { CacheableResponsePlugin } = workbox.cacheableResponse;\r\n  const { ExpirationPlugin } = workbox.expiration;\r\n\r\n  // API calls → network first, cache fallback\r\n  registerRoute(\r\n    ({ url }) => url.href.startsWith('https://story-api.dicoding.dev/'),\r\n    new NetworkFirst({\r\n      cacheName: 'dicoding-api-cache',\r\n      plugins: [\r\n        new CacheableResponsePlugin({ statuses: [0, 200] }),\r\n        new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 30 * 24 * 60 * 60 })\r\n      ]\r\n    })\r\n  );\r\n\r\n  // Google Fonts → stale-while-revalidate\r\n  registerRoute(\r\n    ({ url }) => url.origin.includes('fonts.googleapis.com') || url.origin.includes('fonts.gstatic.com'),\r\n    new StaleWhileRevalidate({\r\n      cacheName: 'google-fonts-cache',\r\n      plugins: [\r\n        new CacheableResponsePlugin({ statuses: [0, 200] }),\r\n        new ExpirationPlugin({ maxEntries: 30, maxAgeSeconds: 365 * 24 * 60 * 60 })\r\n      ]\r\n    })\r\n  );\r\n\r\n  // FontAwesome → cache-first\r\n  registerRoute(\r\n    ({ url }) => url.href.startsWith('https://use.fontawesome.com/releases/'),\r\n    new CacheFirst({\r\n      cacheName: 'fontawesome-cache',\r\n      plugins: [\r\n        new CacheableResponsePlugin({ statuses: [0, 200] }),\r\n        new ExpirationPlugin({ maxEntries: 2, maxAgeSeconds: 365 * 24 * 60 * 60 })\r\n      ]\r\n    })\r\n  );\r\n\r\n  // Offline fallback page\r\n  const offlinePagePath = 'offline.html';            // ← now relative\r\n  setCatchHandler(({ event }) => {\r\n    if (event.request.mode === 'navigate') {\r\n      console.log(`[SW] Fallback to ${offlinePagePath}`);\r\n      return caches.match(offlinePagePath)\r\n        .then(res => res || fetch(offlinePagePath))\r\n        .catch(() => new Response('Offline page not available.', {\r\n          status: 503,\r\n          statusText: 'Offline',\r\n          headers: { 'Content-Type': 'text/plain' }\r\n        }));\r\n    }\r\n    return Response.error();\r\n  });\r\n\r\n} else {\r\n  console.error('[SW] Workbox failed to load.');\r\n}\r\n\r\n// Background sync (unchanged) …\r\nself.addEventListener('sync', /* … */);\r\n\r\n// Push notifications\r\nself.addEventListener('push', event => {\r\n  console.log('[SW] Push received');\r\n  let title = 'Story App';\r\n  let options = {\r\n    body: 'Ada notifikasi!',\r\n    icon: 'images/icon-192.png',\r\n    badge: 'images/icon-192.png',\r\n    data: { url: './#/' }\r\n  };\r\n\r\n  try {\r\n    if (event.data) {\r\n      const data = event.data.json();\r\n      title = data.title || title;\r\n      if (data.options && typeof data.options === 'object') {\r\n        Object.assign(options, data.options);\r\n      }      \r\n    }\r\n  } catch (err) {\r\n    console.warn('[SW] Error parsing push payload:', err);\r\n  }\r\n\r\n  event.waitUntil(\r\n    self.registration.showNotification(title, options)\r\n  );\r\n});\r\n\r\nself.addEventListener('notificationclick', event => {\r\n  event.notification.close();\r\n  const url = event.notification.data?.url || './#/';\r\n  event.waitUntil(\r\n    clients.matchAll({ type: 'window', includeUncontrolled: true })\r\n      .then(list => list.find(c => c.url.endsWith(url))?.focus() || clients.openWindow(url))\r\n  );\r\n});\r\n\r\nself.addEventListener('install', () => { self.skipWaiting(); });\r\nself.addEventListener('activate', () => { clients.claim(); });\r\n"]}