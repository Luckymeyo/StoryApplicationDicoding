{"version":3,"sources":["webpack://app-starter-project-with-webpack/./src/scripts/sw-template.js"],"names":["importScripts","e","console","error","self","getOutboxItems","async","clearOutbox","workbox","log","core","version","precaching","precacheAndRoute","__WB_MANIFEST","registerRoute","setCatchHandler","routing","NetworkFirst","StaleWhileRevalidate","CacheFirst","strategies","CacheableResponsePlugin","cacheableResponse","ExpirationPlugin","expiration","getCacheKeyForURL","url","href","startsWith","cacheName","plugins","statuses","maxEntries","maxAgeSeconds","origin","offlinePagePath","event","request","mode","caches","match","then","r","Response","catch","err","status","statusText","headers","addEventListener","tag","waitUntil","items","length","item","fd","FormData","append","description","photoBlob","photoFileName","lat","lon","res","fetch","method","Authorization","token","body","ok","Error","title","options","icon","badge","data","json","warn","registration","showNotification","targetUrl","notification","close","clients","matchAll","type","includeUncontrolled","clientList","client","location","focus","openWindow","skipWaiting","claim"],"mappings":"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","file":"sw-template.js","sourceRoot":"","sourcesContent":["// src/scripts/sw-template.js\r\nimportScripts('https://storage.googleapis.com/workbox-cdn/releases/7.1.0/workbox-sw.js');\r\n\r\ntry { importScripts('./db.bundle.js'); }\r\ncatch (e) { console.error(\"[SW] Failed DB import:\", e); self.getOutboxItems=async()=>{return[];}; self.clearOutbox=async()=>{}; }\r\n\r\nif (workbox) {\r\n  console.log(`[SW] Workbox ${workbox.core.version} loaded.`);\r\n  workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);\r\n\r\n  const { registerRoute, setCatchHandler } = workbox.routing;\r\n  const { NetworkFirst, StaleWhileRevalidate, CacheFirst } = workbox.strategies;\r\n  const { CacheableResponsePlugin } = workbox.cacheableResponse;\r\n  const { ExpirationPlugin } = workbox.expiration;\r\n  const { getCacheKeyForURL } = workbox.precaching;\r\n\r\n  registerRoute( ({ url }) => url.href.startsWith('https://story-api.dicoding.dev/'), new NetworkFirst({ cacheName: 'dicoding-api-cache', plugins: [ new CacheableResponsePlugin({ statuses: [0, 200] }), new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 30 * 24 * 60 * 60 }), ], }) );\r\n  registerRoute( ({ url }) => url.origin === 'https://fonts.googleapis.com' || url.origin === 'https://fonts.gstatic.com', new StaleWhileRevalidate({ cacheName: 'google-fonts-cache', plugins: [ new CacheableResponsePlugin({ statuses: [0, 200] }), new ExpirationPlugin({ maxEntries: 30, maxAgeSeconds: 365 * 24 * 60 * 60 }), ], }) );\r\n  registerRoute( ({ url }) => url.href.startsWith('https://use.fontawesome.com/releases/'), new CacheFirst({ cacheName: 'fontawesome-cache', plugins: [ new CacheableResponsePlugin({ statuses: [0, 200] }), new ExpirationPlugin({ maxEntries: 2, maxAgeSeconds: 365 * 24 * 60 * 60 }), ], }) );\r\n\r\n  const offlinePagePath = '/StoryApplicationDicoding/offline.html';\r\n  setCatchHandler(({ event }) => {\r\n    switch (event.request.mode) {\r\n      case 'navigate':\r\n        console.log(`[SW] Fallback for navigation. Matching: ${offlinePagePath}`);\r\n        return caches.match(getCacheKeyForURL(offlinePagePath))\r\n          .then(r => r || Response.error()) // Ensure we return Response.error() if match fails before catch\r\n          .catch(err => {\r\n            console.error(`[SW] Offline fallback failed for ${offlinePagePath}:`, err);\r\n            return new Response('Offline page not available.', { status: 503, statusText: 'Offline', headers: { 'Content-Type': 'text/plain' } });\r\n          });\r\n      default: return Response.error();\r\n    }\r\n  });\r\n} else { console.error(\"[SW] Workbox failed to load.\"); }\r\n\r\n// BACKGROUND SYNC\r\nself.addEventListener('sync', event => {\r\n  if (event.tag === 'outbox-sync') {\r\n    console.log('[SW] Sync: outbox-sync triggered');\r\n    event.waitUntil((async () => {\r\n      if (typeof self.getOutboxItems !== 'function') return;\r\n      const items = await self.getOutboxItems();\r\n      if (!items || items.length === 0) return;\r\n\r\n      for (const item of items) {\r\n        try {\r\n          const fd = new FormData();\r\n          fd.append('description', item.description);\r\n          fd.append('photo', item.photoBlob, item.photoFileName || 'photo.jpg');\r\n          if (item.lat) fd.append('lat', item.lat);\r\n          if (item.lon) fd.append('lon', item.lon);\r\n\r\n          const res = await fetch('https://story-api.dicoding.dev/v1/stories', {\r\n            method: 'POST',\r\n            headers: { Authorization: 'Bearer ' + item.token },\r\n            body: fd,\r\n          });\r\n\r\n          if (!res.ok) throw new Error(`Sync failed: ${res.status}`);\r\n          console.log('[SW] Synced item:', item.description);\r\n\r\n        } catch (e) {\r\n          console.error('[SW] Sync error for item:', e);\r\n        }\r\n      }\r\n\r\n      if (typeof self.clearOutbox === 'function') await self.clearOutbox();\r\n    })());\r\n  }\r\n});\r\n\r\n// PUSH EVENT\r\nself.addEventListener('push', event => {\r\n  console.log('[SW] Push Received');\r\n\r\n  let title = 'Story App';\r\n  let options = {\r\n    body: 'Ada notifikasi!',\r\n    icon: '/StoryApplicationDicoding/images/icon-192.png',\r\n    badge: '/StoryApplicationDicoding/images/icon-192.png',\r\n    data: { url: '/StoryApplicationDicoding/' }\r\n  };\r\n\r\n  try {\r\n    if (event.data) {\r\n      const data = event.data.json();\r\n      title = data.title || title;\r\n      options.body = data.body || options.body;\r\n      options.icon = data.icon || options.icon;\r\n      options.badge = data.badge || options.badge;\r\n      options.data = data.data || options.data;\r\n    } else {\r\n      console.warn('[SW] No payload data found. Using fallback values.');\r\n    }\r\n  } catch (err) {\r\n    console.warn('[SW] Failed to parse push event data:', err);\r\n  }\r\n\r\n  event.waitUntil(\r\n    self.registration.showNotification(title, options)\r\n  );\r\n});\r\n\r\n// NOTIFICATION CLICK\r\nself.addEventListener('notificationclick', event => {\r\n  console.log('[SW] Notification clicked');\r\n  const targetUrl = event.notification?.data?.url || '/StoryApplicationDicoding/';\r\n  event.notification.close();\r\n\r\n  event.waitUntil(\r\n    clients.matchAll({ type: 'window', includeUncontrolled: true }).then(clientList => {\r\n      for (const client of clientList) {\r\n        if (client.url === self.location.origin + targetUrl && 'focus' in client) {\r\n          return client.focus();\r\n        }\r\n      }\r\n      if (clients.openWindow) return clients.openWindow(targetUrl);\r\n    })\r\n  );\r\n});\r\n\r\n// INSTALL EVENT\r\nself.addEventListener('install', () => {\r\n  console.log('[SW] Installing...');\r\n  self.skipWaiting(); // Immediately activate new version\r\n});\r\n\r\n// ACTIVATE EVENT\r\nself.addEventListener('activate', event => {\r\n  console.log('[SW] Activating...');\r\n  event.waitUntil(clients.claim());\r\n});\r\n"]}