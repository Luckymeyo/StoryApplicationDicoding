{"version":3,"sources":["webpack://app-starter-project-with-webpack/./src/scripts/sw-template.js"],"names":["importScripts","e","console","error","self","getOutboxItems","async","warn","clearOutbox","workbox","precaching","precacheAndRoute","__WB_MANIFEST","registerRoute","setCatchHandler","routing","NetworkFirst","StaleWhileRevalidate","CacheFirst","strategies","CacheableResponsePlugin","cacheableResponse","ExpirationPlugin","expiration","warmStrategyCache","recipes","url","href","startsWith","cacheName","plugins","statuses","maxEntries","maxAgeSeconds","origin","offlineFallbackPage","networkFirstNavigation","request","mode","handle","args","caches","match","log","addEventListener","event","tag","waitUntil","items","length","item","description","photoBlob","token","formData","FormData","append","photoFileName","lat","lon","response","fetch","method","headers","Authorization","body","ok","errorData","json","catch","message","Error","status","statusText","title","options","icon","badge","data","text","err","registration","showNotification","notificationData","notification","urlToOpen","close","clients","matchAll","type","includeUncontrolled","then","clientList","client","location","focus","openWindow","skipWaiting","claim"],"mappings":"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","file":"service-worker.js","sourceRoot":"","sourcesContent":["// src/scripts/sw-template.js\r\nimportScripts('https://storage.googleapis.com/workbox-cdn/releases/7.1.0/workbox-sw.js');\r\n\r\n// --- IMPORTANT: Handle DB Import ---\r\n// Workbox runs this script directly. Standard module imports might fail.\r\n// We need to ensure db functions are available.\r\n// Option 1 (Simpler if db.js has no complex dependencies): Use importScripts\r\ntry {\r\n  importScripts('./db.bundle.js'); // Assuming webpack bundles db.js separately or it's simple enough\r\n  // You'd need to configure webpack to output db.js (and its dependencies) like this.\r\n  // OR, if db.js is very simple (like only using idb):\r\n  // importScripts('https://unpkg.com/idb@8.0.2/build/iife/index-min.js'); // Import idb library\r\n  // Then re-declare the necessary db functions/constants here (less ideal)\r\n\r\n} catch (e) {\r\n  console.error(\"[SW Template] Failed to import DB functions. Background Sync might fail.\", e);\r\n  // Define dummy functions to prevent immediate errors if import fails\r\n  self.getOutboxItems = async () => { console.warn('getOutboxItems not available'); return []; };\r\n  self.clearOutbox = async () => { console.warn('clearOutbox not available'); };\r\n}\r\n// Option 2 (More robust): Use client messaging. The 'sync' event sends a message\r\n// to an active client window, asks it to perform the DB operations & fetch,\r\n// and waits for a response. This is more complex to implement.\r\n\r\n// Let's proceed assuming db functions become available somehow (e.g., via importScripts),\r\n// but be aware this might need refinement based on your Webpack setup for db.js.\r\n\r\n\r\n// --- Workbox Precaching ---\r\nworkbox.precaching.precacheAndRoute(self.__WB_MANIFEST);\r\n\r\n// --- Workbox Runtime Caching ---\r\nconst { registerRoute, setCatchHandler } = workbox.routing;\r\nconst { NetworkFirst, StaleWhileRevalidate, CacheFirst } = workbox.strategies;\r\nconst { CacheableResponsePlugin } = workbox.cacheableResponse;\r\nconst { ExpirationPlugin } = workbox.expiration;\r\nconst { warmStrategyCache } = workbox.recipes;\r\n\r\n// Cache Dicoding API (Network First)\r\nregisterRoute(\r\n  ({ url }) => url.href.startsWith('https://story-api.dicoding.dev/'),\r\n  new NetworkFirst({\r\n    cacheName: 'dicoding-api-cache',\r\n    plugins: [\r\n      new CacheableResponsePlugin({ statuses: [0, 200] }),\r\n      new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 30 * 24 * 60 * 60 }), // 30 Days\r\n    ],\r\n  })\r\n);\r\n\r\n// Cache Google Fonts (Stale While Revalidate)\r\nregisterRoute(\r\n  ({ url }) => url.origin === 'https://fonts.googleapis.com' || url.origin === 'https://fonts.gstatic.com',\r\n  new StaleWhileRevalidate({\r\n    cacheName: 'google-fonts-cache',\r\n    plugins: [\r\n      new CacheableResponsePlugin({ statuses: [0, 200] }),\r\n      new ExpirationPlugin({ maxEntries: 30, maxAgeSeconds: 365 * 24 * 60 * 60 }), // 1 Year\r\n    ],\r\n  })\r\n);\r\n\r\n// Cache Font Awesome (Cache First)\r\nregisterRoute(\r\n  ({ url }) => url.href.startsWith('https://use.fontawesome.com/releases/'),\r\n  new CacheFirst({\r\n    cacheName: 'fontawesome-cache',\r\n    plugins: [\r\n      new CacheableResponsePlugin({ statuses: [0, 200] }),\r\n      new ExpirationPlugin({ maxEntries: 2, maxAgeSeconds: 365 * 24 * 60 * 60 }), // 1 Year\r\n    ],\r\n  })\r\n);\r\n\r\n// --- Offline Fallback ---\r\nconst offlineFallbackPage = '/offline.html'; // Relative to the scope ('/StoryApplicationDicoding/')\r\n\r\n// Precache the offline page (make sure it's included in webpack output/precache list)\r\n// Workbox's precacheAndRoute should handle this if offline.html is copied by CopyWebpackPlugin\r\n\r\n// Serve offline.html for failed navigation requests\r\nconst networkFirstNavigation = new NetworkFirst({\r\n  cacheName: 'navigation-cache',\r\n  plugins: [\r\n    new CacheableResponsePlugin({ statuses: [0, 200] }),\r\n  ],\r\n});\r\n\r\nregisterRoute(({ request }) => request.mode === 'navigate', async (args) => {\r\n  try {\r\n    // Try network first\r\n    const response = await networkFirstNavigation.handle(args);\r\n    return response || await caches.match(offlineFallbackPage);\r\n  } catch (error) {\r\n    // Network or cache failed, serve the offline page\r\n    console.log('Serving offline fallback for navigation');\r\n    return caches.match(offlineFallbackPage);\r\n  }\r\n});\r\n\r\n\r\n// --- Background Sync ---\r\nself.addEventListener('sync', event => {\r\n  if (event.tag === 'outbox-sync') {\r\n    console.log('[Service Worker] Sync event: outbox-sync');\r\n    event.waitUntil((async () => {\r\n      // Ensure DB functions are loaded/available\r\n      if (typeof self.getOutboxItems !== 'function' || typeof self.clearOutbox !== 'function') {\r\n         console.error(\"DB functions not loaded for sync event. Aborting.\");\r\n         return;\r\n      }\r\n\r\n      const items = await self.getOutboxItems();\r\n      console.log('[Service Worker] Items from outbox:', items);\r\n      if (!items || items.length === 0) {\r\n        console.log('[Service Worker] Outbox is empty.');\r\n        return;\r\n      }\r\n\r\n      for (const item of items) {\r\n        try {\r\n          // !!! CRITICAL: Reconstruct FormData here !!!\r\n          // IndexedDB cannot store FormData directly. `saveOutboxItem` in db.js\r\n          // likely stored the individual fields and the photo Blob.\r\n          // Example reconstruction (adjust based on how you store in `saveOutboxItem`):\r\n          if (!item.description || !item.photoBlob || !item.token) {\r\n             console.error('[Service Worker] Invalid item in outbox:', item);\r\n             continue; // Skip invalid item\r\n          }\r\n\r\n          const formData = new FormData();\r\n          formData.append('description', item.description);\r\n          // Re-create blob from stored data if needed, assuming 'photoBlob' is the stored Blob\r\n          formData.append('photo', item.photoBlob, item.photoFileName || 'photo.jpg');\r\n          if (item.lat) formData.append('lat', item.lat);\r\n          if (item.lon) formData.append('lon', item.lon);\r\n\r\n          console.log('[Service Worker] Attempting to sync item:', item.description);\r\n          const response = await fetch('https://story-api.dicoding.dev/v1/stories', {\r\n            method: 'POST',\r\n            headers: { Authorization: 'Bearer ' + item.token },\r\n            body: formData, // Use the reconstructed FormData\r\n          });\r\n\r\n          if (!response.ok) {\r\n            const errorData = await response.json().catch(() => ({ message: 'Unknown error' }));\r\n            throw new Error(`Sync failed for item ${item.description}: ${response.status} ${response.statusText} - ${errorData.message}`);\r\n          }\r\n          console.log(`[Service Worker] Item ${item.description} synced successfully.`);\r\n\r\n        } catch (error) {\r\n          console.error('[Service Worker] Failed to sync item:', item, error);\r\n          // Decide if you want to retry later or clear the item anyway\r\n          // For now, we'll continue trying other items\r\n        }\r\n      }\r\n      // Clear only if all items were processed (successfully or unsuccessfully)\r\n      // Or implement more granular clearing based on success.\r\n      console.log('[Service Worker] Clearing outbox after sync attempt.');\r\n      await self.clearOutbox();\r\n\r\n    })());\r\n  }\r\n});\r\n\r\n\r\n// --- Push Notification Listener ---\r\nself.addEventListener('push', event => {\r\n  console.log('[Service Worker] Push Received.');\r\n  let title = 'Story App'; // Default title\r\n  let options = {\r\n    body: 'Ada notifikasi baru!', // Default body\r\n    icon: 'images/icon-192.png', // Make sure path is relative to origin root\r\n    badge: 'images/icon-192.png', // Make sure path is relative to origin root\r\n    data: { url: '/' } // Default click action URL\r\n  };\r\n\r\n  try {\r\n    const data = event.data.json();\r\n    console.log('[Service Worker] Push data:', data);\r\n    title = data.title || title;\r\n    options.body = data.body || options.body;\r\n    options.icon = data.icon || options.icon;\r\n    options.badge = data.badge || options.badge;\r\n    options.data = data.data || options.data; // Store any extra data\r\n  } catch (e) {\r\n     console.warn('[Service Worker] Push data is not JSON, trying as text.');\r\n     try {\r\n       options.body = event.data.text() || options.body;\r\n     } catch (err) {\r\n       console.warn('[Service Worker] Could not read push data as text.');\r\n     }\r\n  }\r\n\r\n  event.waitUntil(\r\n    self.registration.showNotification(title, options)\r\n  );\r\n});\r\n\r\n// --- Notification Click Listener ---\r\nself.addEventListener('notificationclick', event => {\r\n  console.log('[Service Worker] Notification click Received.');\r\n  const notificationData = event.notification.data;\r\n  const urlToOpen = notificationData?.url || '/'; // Use URL from data or fallback\r\n\r\n  event.notification.close();\r\n\r\n  event.waitUntil(\r\n    clients.matchAll({ type: 'window', includeUncontrolled: true })\r\n      .then(clientList => {\r\n        // Check if a window is already open at the target URL\r\n        for (const client of clientList) {\r\n          // Adjust URL comparison if needed (e.g., ignore hash)\r\n          if (client.url === self.location.origin + urlToOpen && 'focus' in client) {\r\n            return client.focus();\r\n          }\r\n        }\r\n        // If not open, open a new window\r\n        if (clients.openWindow) {\r\n          return clients.openWindow(urlToOpen);\r\n        }\r\n      })\r\n  );\r\n});\r\n\r\n// --- Service Worker Lifecycle ---\r\nself.addEventListener('install', () => {\r\n  console.log('[Service Worker] Installing...');\r\n  self.skipWaiting(); // Activate worker immediately\r\n});\r\n\r\nself.addEventListener('activate', event => {\r\n  console.log('[Service Worker] Activating...');\r\n  // Clean up old caches managed by previous versions of this SW\r\n  // Workbox handles its own cache cleanup automatically.\r\n  // If you had manually named caches before, delete them here.\r\n  event.waitUntil(clients.claim()); // Take control of pages immediately\r\n});"]}