{"version":3,"sources":["webpack://app-starter-project-with-webpack/./src/scripts/sw-template.js"],"names":["importScripts","e","console","error","self","getOutboxItems","async","warn","clearOutbox","workbox","log","core","version","precaching","precacheAndRoute","__WB_MANIFEST","registerRoute","setCatchHandler","routing","NetworkFirst","StaleWhileRevalidate","CacheFirst","strategies","CacheableResponsePlugin","cacheableResponse","ExpirationPlugin","expiration","getCacheKeyForURL","url","href","startsWith","cacheName","plugins","statuses","maxEntries","maxAgeSeconds","origin","offlinePagePath","event","request","mode","caches","match","then","cachedResponse","Response","status","statusText","headers","catch","err","addEventListener","tag","waitUntil","items","length","item","formData","FormData","append","description","photoBlob","photoFileName","lat","lon","response","fetch","method","Authorization","token","body","ok","errorData","json","message","Error","title","options","icon","badge","data","text","registration","showNotification","urlToOpen","notification","close","clients","matchAll","type","includeUncontrolled","clientList","client","location","focus","openWindow","skipWaiting","claim"],"mappings":"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","file":"service-worker.js","sourceRoot":"","sourcesContent":["// src/scripts/sw-template.js\r\nimportScripts('https://storage.googleapis.com/workbox-cdn/releases/7.1.0/workbox-sw.js');\r\n\r\ntry {\r\n  // This will still fail until db bundling is configured, affecting Background Sync.\r\n  importScripts('./db.bundle.js');\r\n} catch (e) {\r\n  console.error(\"[SW Template] Failed to import DB functions. Background Sync might fail.\", e);\r\n  self.getOutboxItems = async () => { console.warn('getOutboxItems not available'); return []; };\r\n  self.clearOutbox = async () => { console.warn('clearOutbox not available'); };\r\n}\r\n\r\nif (workbox) {\r\n  console.log(`[SW] Workbox ${workbox.core.version} loaded.`);\r\n  // Configure precaching\r\n  workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);\r\n\r\n  // Import necessary Workbox modules\r\n  const { registerRoute, setCatchHandler } = workbox.routing;\r\n  const { NetworkFirst, StaleWhileRevalidate, CacheFirst } = workbox.strategies;\r\n  const { CacheableResponsePlugin } = workbox.cacheableResponse;\r\n  const { ExpirationPlugin } = workbox.expiration;\r\n  const { precacheAndRoute, getCacheKeyForURL } = workbox.precaching; // Ensure this is imported/available\r\n\r\n  // --- Runtime Caching ---\r\n  registerRoute( ({ url }) => url.href.startsWith('https://story-api.dicoding.dev/'), new NetworkFirst({ cacheName: 'dicoding-api-cache', plugins: [ new CacheableResponsePlugin({ statuses: [0, 200] }), new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 30 * 24 * 60 * 60 }), ], }) );\r\n  registerRoute( ({ url }) => url.origin === 'https://fonts.googleapis.com' || url.origin === 'https://fonts.gstatic.com', new StaleWhileRevalidate({ cacheName: 'google-fonts-cache', plugins: [ new CacheableResponsePlugin({ statuses: [0, 200] }), new ExpirationPlugin({ maxEntries: 30, maxAgeSeconds: 365 * 24 * 60 * 60 }), ], }) );\r\n  registerRoute( ({ url }) => url.href.startsWith('https://use.fontawesome.com/releases/'), new CacheFirst({ cacheName: 'fontawesome-cache', plugins: [ new CacheableResponsePlugin({ statuses: [0, 200] }), new ExpirationPlugin({ maxEntries: 2, maxAgeSeconds: 365 * 24 * 60 * 60 }), ], }) );\r\n\r\n  // --- CORRECTED Offline Fallback ---\r\n  const offlinePagePath = '/StoryApplicationDicoding/offline.html'; // Exact path from cache\r\n\r\n  setCatchHandler(({ event }) => {\r\n    switch (event.request.mode) {\r\n      case 'navigate':\r\n        console.log(`[SW] Attempting offline fallback for navigation. Trying to match cache key for: ${offlinePagePath}`);\r\n        // Use getCacheKeyForURL to ensure correct matching against the precache manifest\r\n        return caches.match(getCacheKeyForURL(offlinePagePath))\r\n               .then(cachedResponse => {\r\n                  if (cachedResponse) {\r\n                    console.log(`[SW] Serving offline fallback: ${offlinePagePath}`);\r\n                    return cachedResponse;\r\n                  }\r\n                  // This should ideally not be reached if offline.html is correctly precached\r\n                  console.error(`[SW] CRITICAL: Offline fallback page ('${offlinePagePath}') not found in cache!`);\r\n                  return new Response('Network error: You are offline and the fallback page is not available.', {\r\n                    status: 503,\r\n                    statusText: 'Service Unavailable',\r\n                    headers: { 'Content-Type': 'text/plain' },\r\n                  });\r\n               })\r\n               .catch(err => {\r\n                  console.error('[SW] Error during caches.match for offline fallback:', err);\r\n                  return new Response('Offline error occurred.', { status: 500, headers: { 'Content-Type': 'text/plain' }});\r\n               });\r\n      default:\r\n        // For non-navigation requests (images, scripts, etc.), return a standard network error.\r\n        return Response.error();\r\n    }\r\n  });\r\n  // --- END CORRECTED Offline Fallback ---\r\n\r\n} else {\r\n   console.error(\"[SW] Workbox library did not load!\");\r\n}\r\n\r\n// --- Background Sync (Keep as is, db import still needs fix) ---\r\nself.addEventListener('sync', event => { if (event.tag === 'outbox-sync') { console.log('[SW] Sync event: outbox-sync'); event.waitUntil((async () => { if (typeof self.getOutboxItems !== 'function') { console.error(\"DB functions not loaded for sync event.\"); return; } const items = await self.getOutboxItems(); if (!items || items.length === 0) return; for (const item of items) { try { const formData = new FormData(); formData.append('description', item.description); formData.append('photo', item.photoBlob, item.photoFileName || 'photo.jpg'); if (item.lat) formData.append('lat', item.lat); if (item.lon) formData.append('lon', item.lon); console.log('[SW] Syncing item:', item.description); const response = await fetch('https://story-api.dicoding.dev/v1/stories', { method: 'POST', headers: { Authorization: 'Bearer ' + item.token }, body: formData }); if (!response.ok) { const errorData = await response.json().catch(() => ({ message: 'Unknown sync error' })); throw new Error(`Sync failed: ${response.status} - ${errorData.message}`); } console.log(`[SW] Item ${item.description} synced.`); } catch (error) { console.error('[SW] Failed sync item:', error); } } if(typeof self.clearOutbox === 'function') await self.clearOutbox(); })()); } });\r\n\r\n// --- Push Listener (Keep as is) ---\r\nself.addEventListener('push', event => { console.log('[SW] Push Received.'); let title = 'Story App'; let options = { body: 'Ada notifikasi baru!', icon: '/StoryApplicationDicoding/images/icon-192.png', badge: '/StoryApplicationDicoding/images/icon-192.png', data: { url: '/StoryApplicationDicoding/' } }; try { const data = event.data.json(); title = data.title || title; options.body = data.body || options.body; options.icon = data.icon || options.icon; options.badge = data.badge || options.badge; options.data = data.data || options.data; } catch (e) { try { options.body = event.data.text() || options.body; } catch (err) { console.warn('[SW] Could not read push data.'); } } event.waitUntil( self.registration.showNotification(title, options) ); });\r\n\r\n// --- Notification Click Listener (Keep as is) ---\r\nself.addEventListener('notificationclick', event => { console.log('[SW] Notification click Received.'); const urlToOpen = event.notification.data?.url || '/StoryApplicationDicoding/'; event.notification.close(); event.waitUntil( clients.matchAll({ type: 'window', includeUncontrolled: true }).then(clientList => { for (const client of clientList) { if (client.url === self.location.origin + urlToOpen && 'focus' in client) { return client.focus(); } } if (clients.openWindow) { return clients.openWindow(urlToOpen); } }) ); });\r\n\r\n// --- Lifecycle (Keep as is) ---\r\nself.addEventListener('install', () => { console.log('[SW] Installing...'); self.skipWaiting(); });\r\nself.addEventListener('activate', event => { console.log('[SW] Activating...'); event.waitUntil(clients.claim()); });"]}