{"version":3,"sources":["webpack://app-starter-project-with-webpack/./src/scripts/sw-template.js"],"names":["importScripts","e","console","error","self","getOutboxItems","async","warn","clearOutbox","workbox","manifest","__WB_MANIFEST","filter","entry","url","endsWith","precaching","precacheAndRoute","registerRoute","setCatchHandler","routing","NetworkFirst","StaleWhileRevalidate","CacheFirst","strategies","CacheableResponsePlugin","cacheableResponse","ExpirationPlugin","expiration","href","startsWith","cacheName","plugins","statuses","maxEntries","maxAgeSeconds","origin","getCacheKeyForURL","offlinePagePath","event","request","mode","caches","match","then","cachedResponse","log","Response","status","statusText","headers","catch","err","addEventListener","tag","waitUntil","items","length","item","title","options","data","json","registration","showNotification","urlToOpen","notification","close","clients","matchAll","type","includeUncontrolled","windowClients","client","focus","openWindow","skipWaiting","claim"],"mappings":"MAAA,cAAc,2EAEd,IACE,cAAc,eAChB,CAAE,MAAO,GACP,QAAQ,MAAM,2EAA4E,GAC1F,KAAK,eAAiB,UAAc,QAAQ,KAAK,gCAAwC,IACzF,KAAK,YAAc,UAAc,QAAQ,KAAK,4BAA4B,CAC5E,CAEA,GAAI,QAAS,CAEX,MAAM,EAAW,oiDAAK,cAAc,QAAO,IAAU,EAAM,IAAI,SAAS,kBACxE,QAAQ,WAAW,iBAAiB,EACtC,MACE,QAAQ,MAAM,+BAGhB,GAAI,QAAS,CACX,MAAM,cAAE,EAAa,gBAAE,GAAoB,QAAQ,SAC7C,aAAE,EAAY,qBAAE,EAAoB,WAAE,GAAe,QAAQ,YAC7D,wBAAE,GAA4B,QAAQ,mBACtC,iBAAE,GAAqB,QAAQ,WAGrC,GACE,EAAG,SAAU,EAAI,KAAK,WAAW,oCACjC,IAAI,EAAa,CACf,UAAW,qBACX,QAAS,CACP,IAAI,EAAwB,CAAE,SAAU,CAAC,EAAG,OAC5C,IAAI,EAAiB,CAAE,WAAY,IAAK,cAAe,aAM7D,GACE,EAAG,SAAyB,iCAAf,EAAI,QAA4D,8BAAf,EAAI,QAClE,IAAI,EAAqB,CACvB,UAAW,qBACX,QAAS,CACP,IAAI,EAAwB,CAAE,SAAU,CAAC,EAAG,OAC5C,IAAI,EAAiB,CAAE,WAAY,GAAI,cAAe,cAM5D,GACE,EAAG,SAAU,EAAI,KAAK,WAAW,0CACjC,IAAI,EAAW,CACb,UAAW,oBACX,QAAS,CACP,IAAI,EAAwB,CAAE,SAAU,CAAC,EAAG,OAC5C,IAAI,EAAiB,CAAE,WAAY,EAAG,cAAe,cAM3D,MAAM,kBAAE,GAAsB,QAAQ,WAChC,EAAkB,yCAExB,GAAgB,EAAG,WACU,aAAvB,EAAM,QAAQ,KACT,OAAO,MAAM,EAAkB,IACnC,MAAK,GACA,GACF,QAAQ,IAAI,kCAAkC,KACvC,IAET,QAAQ,MAAM,gCAAgC,2BACvC,IAAI,SAAS,yEAA0E,CAC5F,OAAQ,IACR,WAAY,sBACZ,QAAS,CAAE,eAAgB,mBAG9B,OAAM,IACL,QAAQ,MAAM,sCAAuC,GAC9C,IAAI,SAAS,0BAA2B,CAC7C,OAAQ,IACR,QAAS,CAAE,eAAgB,mBAI5B,SAAS,SAIpB,MACE,QAAQ,MAAM,8CAIhB,KAAK,iBAAiB,QAAQ,IACV,gBAAd,EAAM,MACR,QAAQ,IAAI,4CACZ,EAAM,UAAU,WACd,GAAmC,mBAAxB,KAAK,gBAA6D,mBAArB,KAAK,YAE3D,YADA,QAAQ,MAAM,qDAGhB,MAAM,QAAc,KAAK,iBACzB,GAAK,GAA0B,IAAjB,EAAM,OAApB,CACA,IAAK,MAAM,KAAQ,SAGb,KAAK,aAJ6B,CAKzC,EAXe,IAYlB,IAIF,KAAK,iBAAiB,QAAQ,IAC5B,QAAQ,IAAI,mCACZ,IAAI,EAAQ,YACR,EAAU,CAAC,EACf,IACE,MAAM,EAAO,EAAM,KAAK,OACxB,EAAQ,EAAK,OAAS,EACtB,EAAU,IAAK,EACjB,CAAE,MAAO,GACP,QAAQ,MAAM,gCAAiC,EACjD,CACA,EAAM,UAAU,KAAK,aAAa,iBAAiB,EAAO,GAAS,IAIrE,KAAK,iBAAiB,qBAAqB,IACzC,QAAQ,IAAI,iDACZ,MAAM,EAAY,EAAM,aAAa,MAAM,KAAO,6BAClD,EAAM,aAAa,QACnB,EAAM,UACJ,QAAQ,SAAS,CAAE,KAAM,SAAU,qBAAqB,IAAQ,MAAK,IACnE,IAAK,MAAM,KAAU,EACnB,GAAI,EAAO,MAAQ,GAAa,UAAW,EACzC,OAAO,EAAO,QAGlB,GAAI,QAAQ,WACV,OAAO,QAAQ,WAAW,EAC5B,IAEH,IAIH,KAAK,iBAAiB,WAAW,KAC/B,QAAQ,IAAI,kCACZ,KAAK,aAAa,IAGpB,KAAK,iBAAiB,YAAY,IAChC,QAAQ,IAAI,kCACZ,EAAM,UAAU,QAAQ,QAAQ","file":"service-worker.js","sourceRoot":"","sourcesContent":["importScripts('https://storage.googleapis.com/workbox-cdn/releases/7.1.0/workbox-sw.js');\r\n\r\ntry {\r\n  importScripts('db.bundle.js');\r\n} catch (e) {\r\n  console.error(\"[SW Template] Failed to import DB functions. Background Sync might fail.\", e);\r\n  self.getOutboxItems = async () => { console.warn('getOutboxItems not available'); return []; };\r\n  self.clearOutbox = async () => { console.warn('clearOutbox not available'); };\r\n}\r\n\r\nif (workbox) {\r\n  // Filter out duplicate favicon entry before precaching\r\n  const manifest = self.__WB_MANIFEST.filter(entry => !entry.url.endsWith('/favicon.png'));\r\n  workbox.precaching.precacheAndRoute(manifest);\r\n} else {\r\n  console.error(\"Workbox library not loaded.\");\r\n}\r\n\r\nif (workbox) {\r\n  const { registerRoute, setCatchHandler } = workbox.routing;\r\n  const { NetworkFirst, StaleWhileRevalidate, CacheFirst } = workbox.strategies;\r\n  const { CacheableResponsePlugin } = workbox.cacheableResponse;\r\n  const { ExpirationPlugin } = workbox.expiration;\r\n\r\n  // Cache Dicoding API (Network First)\r\n  registerRoute(\r\n    ({ url }) => url.href.startsWith('https://story-api.dicoding.dev/'),\r\n    new NetworkFirst({\r\n      cacheName: 'dicoding-api-cache',\r\n      plugins: [\r\n        new CacheableResponsePlugin({ statuses: [0, 200] }),\r\n        new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 30 * 24 * 60 * 60 }), // 30 Days\r\n      ],\r\n    })\r\n  );\r\n\r\n  // Cache Google Fonts (Stale While Revalidate)\r\n  registerRoute(\r\n    ({ url }) => url.origin === 'https://fonts.googleapis.com' || url.origin === 'https://fonts.gstatic.com',\r\n    new StaleWhileRevalidate({\r\n      cacheName: 'google-fonts-cache',\r\n      plugins: [\r\n        new CacheableResponsePlugin({ statuses: [0, 200] }),\r\n        new ExpirationPlugin({ maxEntries: 30, maxAgeSeconds: 365 * 24 * 60 * 60 }), // 1 Year\r\n      ],\r\n    })\r\n  );\r\n\r\n  // Cache Font Awesome (Cache First)\r\n  registerRoute(\r\n    ({ url }) => url.href.startsWith('https://use.fontawesome.com/releases/'),\r\n    new CacheFirst({\r\n      cacheName: 'fontawesome-cache',\r\n      plugins: [\r\n        new CacheableResponsePlugin({ statuses: [0, 200] }),\r\n        new ExpirationPlugin({ maxEntries: 2, maxAgeSeconds: 365 * 24 * 60 * 60 }), // 1 Year\r\n      ],\r\n    })\r\n  );\r\n\r\n  // --- Offline Fallback ---\r\n  const { getCacheKeyForURL } = workbox.precaching;\r\n  const offlinePagePath = '/StoryApplicationDicoding/offline.html';\r\n\r\n  setCatchHandler(({ event }) => {\r\n    if (event.request.mode === 'navigate') {\r\n      return caches.match(getCacheKeyForURL(offlinePagePath))\r\n        .then(cachedResponse => {\r\n          if (cachedResponse) {\r\n            console.log(`[SW] Serving offline fallback: ${offlinePagePath}`);\r\n            return cachedResponse;\r\n          }\r\n          console.error(`[SW] Offline fallback page ('${offlinePagePath}') not found in cache.`);\r\n          return new Response('Network error: You are offline and the fallback page is not available.', {\r\n            status: 503,\r\n            statusText: 'Service Unavailable',\r\n            headers: { 'Content-Type': 'text/plain' },\r\n          });\r\n        })\r\n        .catch(err => {\r\n          console.error('[SW] Error during offline fallback:', err);\r\n          return new Response('Offline error occurred.', {\r\n            status: 500,\r\n            headers: { 'Content-Type': 'text/plain' }\r\n          });\r\n        });\r\n    }\r\n    return Response.error();\r\n  });\r\n  // --- End Offline Fallback ---\r\n\r\n} else {\r\n  console.error(\"Workbox routing and strategies not loaded.\");\r\n}\r\n\r\n// --- Background Sync ---\r\nself.addEventListener('sync', event => {\r\n  if (event.tag === 'outbox-sync') {\r\n    console.log('[Service Worker] Sync event: outbox-sync');\r\n    event.waitUntil((async () => {\r\n      if (typeof self.getOutboxItems !== 'function' || typeof self.clearOutbox !== 'function') {\r\n        console.error(\"DB functions not loaded for sync event. Aborting.\");\r\n        return;\r\n      }\r\n      const items = await self.getOutboxItems();\r\n      if (!items || items.length === 0) return;\r\n      for (const item of items) {\r\n        // ... your sync logic here ...\r\n      }\r\n      await self.clearOutbox();\r\n    })());\r\n  }\r\n});\r\n\r\n// --- Push Notification Listener ---\r\nself.addEventListener('push', event => {\r\n  console.log('[Service Worker] Push Received.');\r\n  let title = 'Story App';\r\n  let options = {};\r\n  try {\r\n    const data = event.data.json();\r\n    title = data.title || title;\r\n    options = { ...data };\r\n  } catch (e) {\r\n    console.error('[SW] Error parsing push data:', e);\r\n  }\r\n  event.waitUntil(self.registration.showNotification(title, options));\r\n});\r\n\r\n// --- Notification Click Listener ---\r\nself.addEventListener('notificationclick', event => {\r\n  console.log('[Service Worker] Notification click Received.');\r\n  const urlToOpen = event.notification.data?.url || '/StoryApplicationDicoding/';\r\n  event.notification.close();\r\n  event.waitUntil(\r\n    clients.matchAll({ type: 'window', includeUncontrolled: true }).then(windowClients => {\r\n      for (const client of windowClients) {\r\n        if (client.url === urlToOpen && 'focus' in client) {\r\n          return client.focus();\r\n        }\r\n      }\r\n      if (clients.openWindow) {\r\n        return clients.openWindow(urlToOpen);\r\n      }\r\n    })\r\n  );\r\n});\r\n\r\n// --- Service Worker Lifecycle ---\r\nself.addEventListener('install', () => {\r\n  console.log('[Service Worker] Installing...');\r\n  self.skipWaiting();\r\n});\r\n\r\nself.addEventListener('activate', event => {\r\n  console.log('[Service Worker] Activating...');\r\n  event.waitUntil(clients.claim());\r\n});\r\n"]}