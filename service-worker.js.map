{"version":3,"sources":["webpack://app-starter-project-with-webpack/./src/scripts/sw-template.js"],"names":["importScripts","e","console","error","self","getOutboxItems","async","warn","clearOutbox","workbox","precaching","precacheAndRoute","__WB_MANIFEST","registerRoute","setCatchHandler","routing","NetworkFirst","StaleWhileRevalidate","CacheFirst","strategies","CacheableResponsePlugin","cacheableResponse","ExpirationPlugin","expiration","url","href","startsWith","cacheName","plugins","statuses","maxEntries","maxAgeSeconds","origin","getCacheKeyForURL","offlinePagePath","event","request","mode","caches","match","then","cachedResponse","log","Response","status","statusText","headers","catch","err","addEventListener","tag","waitUntil","items","length","item","registration","showNotification","notification","data","close","clients","matchAll","skipWaiting","claim"],"mappings":"MAAA,cAAc,2EAEd,IACE,cAAc,iBAChB,CAAE,MAAO,GACP,QAAQ,MAAM,2EAA4E,GAC1F,KAAK,eAAiB,UAAc,QAAQ,KAAK,gCAAwC,IACzF,KAAK,YAAc,UAAc,QAAQ,KAAK,4BAA4B,CAC5E,CAUA,GARI,QACF,QAAQ,WAAW,iBAAiB,q3CAAK,eAEzC,QAAQ,MAAM,+BAKZ,QAAS,CACX,MAAM,cAAE,EAAa,gBAAE,GAAoB,QAAQ,SAC7C,aAAE,EAAY,qBAAE,EAAoB,WAAE,GAAe,QAAQ,YAC7D,wBAAE,GAA4B,QAAQ,mBACtC,iBAAE,GAAqB,QAAQ,WAGrC,GACE,EAAG,SAAU,EAAI,KAAK,WAAW,oCACjC,IAAI,EAAa,CACf,UAAW,qBACX,QAAS,CACP,IAAI,EAAwB,CAAE,SAAU,CAAC,EAAG,OAC5C,IAAI,EAAiB,CAAE,WAAY,IAAK,cAAe,aAM7D,GACE,EAAG,SAAyB,iCAAf,EAAI,QAA4D,8BAAf,EAAI,QAClE,IAAI,EAAqB,CACvB,UAAW,qBACX,QAAS,CACP,IAAI,EAAwB,CAAE,SAAU,CAAC,EAAG,OAC5C,IAAI,EAAiB,CAAE,WAAY,GAAI,cAAe,cAM5D,GACE,EAAG,SAAU,EAAI,KAAK,WAAW,0CACjC,IAAI,EAAW,CACb,UAAW,oBACX,QAAS,CACP,IAAI,EAAwB,CAAE,SAAU,CAAC,EAAG,OAC5C,IAAI,EAAiB,CAAE,WAAY,EAAG,cAAe,cAM3D,MAAM,iBAAE,EAAgB,kBAAE,GAAsB,QAAQ,WAGlD,EAAkB,yCAUxB,GAAgB,EAAG,WAGV,aADC,EAAM,QAAQ,KAGX,OAAO,MAAM,EAAkB,IAC9B,MAAK,GACC,GACF,QAAQ,IAAI,kCAAkC,KACvC,IAGT,QAAQ,MAAM,gCAAgC,2BACvC,IAAI,SAAS,yEAA0E,CAC5F,OAAQ,IACR,WAAY,sBACZ,QAAS,CAAE,eAAgB,mBAG/B,OAAM,IACJ,QAAQ,MAAM,sCAAuC,GAC9C,IAAI,SAAS,0BAA2B,CAAE,OAAQ,IAAK,QAAS,CAAE,eAAgB,mBAI5F,SAAS,SAKxB,MACG,QAAQ,MAAM,8CAMjB,KAAK,iBAAiB,QAAQ,IACV,gBAAd,EAAM,MACR,QAAQ,IAAI,4CACZ,EAAM,UAAU,WACd,GAAmC,mBAAxB,KAAK,gBAA6D,mBAArB,KAAK,YAE1D,YADA,QAAQ,MAAM,qDAGjB,MAAM,QAAc,KAAK,iBAEzB,GAAK,GAA0B,IAAjB,EAAM,OAApB,CACA,IAAK,MAAM,KAAQ,SACb,KAAK,aAF6B,CAGzC,EAVe,IAWlB,IAMF,KAAK,iBAAiB,QAAQ,IAC5B,QAAQ,IAAI,mCAIZ,EAAM,UAAW,KAAK,aAAa,iBAFvB,YAA2B,CAAgB,GAEc,IAKvE,KAAK,iBAAiB,qBAAqB,IACzC,QAAQ,IAAI,iDAEO,EAAM,aAAa,KACrC,EAAM,aAAa,QACnB,EAAM,UAAW,QAAQ,WAAkB,OAAkC,IAKhF,KAAK,iBAAiB,WAAW,KAC/B,QAAQ,IAAI,kCACZ,KAAK,aAAa,IAGpB,KAAK,iBAAiB,YAAY,IAChC,QAAQ,IAAI,kCACZ,EAAM,UAAU,QAAQ,QAAQ","file":"service-worker.js","sourceRoot":"","sourcesContent":["importScripts('https://storage.googleapis.com/workbox-cdn/releases/7.1.0/workbox-sw.js');\r\n\r\ntry {\r\n  importScripts('./db.bundle.js');\r\n} catch (e) {\r\n  console.error(\"[SW Template] Failed to import DB functions. Background Sync might fail.\", e);\r\n  self.getOutboxItems = async () => { console.warn('getOutboxItems not available'); return []; };\r\n  self.clearOutbox = async () => { console.warn('clearOutbox not available'); };\r\n}\r\n\r\nif (workbox) {\r\n  workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);\r\n} else {\r\n  console.error(\"Workbox library not loaded.\");\r\n}\r\n\r\n\r\n\r\nif (workbox) {\r\n  const { registerRoute, setCatchHandler } = workbox.routing;\r\n  const { NetworkFirst, StaleWhileRevalidate, CacheFirst } = workbox.strategies;\r\n  const { CacheableResponsePlugin } = workbox.cacheableResponse;\r\n  const { ExpirationPlugin } = workbox.expiration;\r\n\r\n  // Cache Dicoding API (Network First)\r\n  registerRoute(\r\n    ({ url }) => url.href.startsWith('https://story-api.dicoding.dev/'),\r\n    new NetworkFirst({\r\n      cacheName: 'dicoding-api-cache',\r\n      plugins: [\r\n        new CacheableResponsePlugin({ statuses: [0, 200] }),\r\n        new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 30 * 24 * 60 * 60 }), // 30 Days\r\n      ],\r\n    })\r\n  );\r\n\r\n  // Cache Google Fonts (Stale While Revalidate)\r\n  registerRoute(\r\n    ({ url }) => url.origin === 'https://fonts.googleapis.com' || url.origin === 'https://fonts.gstatic.com',\r\n    new StaleWhileRevalidate({\r\n      cacheName: 'google-fonts-cache',\r\n      plugins: [\r\n        new CacheableResponsePlugin({ statuses: [0, 200] }),\r\n        new ExpirationPlugin({ maxEntries: 30, maxAgeSeconds: 365 * 24 * 60 * 60 }), // 1 Year\r\n      ],\r\n    })\r\n  );\r\n\r\n  // Cache Font Awesome (Cache First)\r\n  registerRoute(\r\n    ({ url }) => url.href.startsWith('https://use.fontawesome.com/releases/'),\r\n    new CacheFirst({\r\n      cacheName: 'fontawesome-cache',\r\n      plugins: [\r\n        new CacheableResponsePlugin({ statuses: [0, 200] }),\r\n        new ExpirationPlugin({ maxEntries: 2, maxAgeSeconds: 365 * 24 * 60 * 60 }), // 1 Year\r\n      ],\r\n    })\r\n  );\r\n\r\n  // --- CORRECTED Offline Fallback ---\r\n  const { precacheAndRoute, getCacheKeyForURL } = workbox.precaching;\r\n\r\n  // Define the FULL path to the offline page, matching the publicPath\r\n  const offlinePagePath = '/StoryApplicationDicoding/offline.html';\r\n\r\n\r\n  // self.addEventListener('install', event => {\r\n  //   event.waitUntil(\r\n  //     caches.open(workbox.core.cacheNames.precache).then(cache => cache.add(offlinePagePath))\r\n  //   );\r\n  // });\r\n  // However, additionalManifestEntries in webpack.prod.js should be sufficient.\r\n\r\n  setCatchHandler(({ event }) => {\r\n    // Only handle navigation requests.\r\n    switch (event.request.mode) {\r\n      case 'navigate':\r\n        // Try to return the precached offline page using the correct cache key.\r\n        return caches.match(getCacheKeyForURL(offlinePagePath))\r\n               .then(cachedResponse => {\r\n                  if (cachedResponse) {\r\n                    console.log(`[SW] Serving offline fallback: ${offlinePagePath}`);\r\n                    return cachedResponse;\r\n                  }\r\n                  // Fallback if offline.html itself isn't cached for some reason\r\n                  console.error(`[SW] Offline fallback page ('${offlinePagePath}') not found in cache.`);\r\n                  return new Response('Network error: You are offline and the fallback page is not available.', {\r\n                    status: 503,\r\n                    statusText: 'Service Unavailable',\r\n                    headers: { 'Content-Type': 'text/plain' },\r\n                  });\r\n               })\r\n               .catch(err => {\r\n                  console.error('[SW] Error during offline fallback:', err);\r\n                  return new Response('Offline error occurred.', { status: 500, headers: { 'Content-Type': 'text/plain' }});\r\n               });\r\n      default:\r\n        // For non-navigation requests, return a standard network error.\r\n        return Response.error();\r\n    }\r\n  });\r\n  // --- END CORRECTED Offline Fallback ---\r\n\r\n} else {\r\n   console.error(\"Workbox routing and strategies not loaded.\");\r\n}\r\n\r\n\r\n// --- Background Sync ---\r\n// Keep existing logic, but be aware importScripts still needs fixing for it to work\r\nself.addEventListener('sync', event => {\r\n  if (event.tag === 'outbox-sync') {\r\n    console.log('[Service Worker] Sync event: outbox-sync');\r\n    event.waitUntil((async () => {\r\n      if (typeof self.getOutboxItems !== 'function' || typeof self.clearOutbox !== 'function') {\r\n         console.error(\"DB functions not loaded for sync event. Aborting.\");\r\n         return;\r\n      }\r\n      const items = await self.getOutboxItems();\r\n      // ... (rest of sync logic with FormData reconstruction) ...\r\n      if (!items || items.length === 0) return;\r\n      for (const item of items) { /* ... fetch logic ... */ }\r\n      await self.clearOutbox();\r\n    })());\r\n  }\r\n});\r\n\r\n\r\n// --- Push Notification Listener ---\r\n// Keep existing logic\r\nself.addEventListener('push', event => {\r\n  console.log('[Service Worker] Push Received.');\r\n  // ... (rest of push logic) ...\r\n  let title = 'Story App'; let options = { /* defaults */ };\r\n  try { /* parse data */ } catch (e) { /* handle error */ }\r\n  event.waitUntil( self.registration.showNotification(title, options) );\r\n});\r\n\r\n// --- Notification Click Listener ---\r\n// Keep existing logic\r\nself.addEventListener('notificationclick', event => {\r\n  console.log('[Service Worker] Notification click Received.');\r\n  // ... (rest of notification click logic) ...\r\n   const urlToOpen = event.notification.data?.url || '/StoryApplicationDicoding/'; // Ensure click opens correct base path\r\n   event.notification.close();\r\n   event.waitUntil( clients.matchAll(/*...*/).then(/* focus or open window */) );\r\n});\r\n\r\n// --- Service Worker Lifecycle ---\r\n// Keep existing logic\r\nself.addEventListener('install', () => {\r\n  console.log('[Service Worker] Installing...');\r\n  self.skipWaiting();\r\n});\r\n\r\nself.addEventListener('activate', event => {\r\n  console.log('[Service Worker] Activating...');\r\n  event.waitUntil(clients.claim());\r\n});"]}